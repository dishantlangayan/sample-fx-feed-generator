/**
 * Copyright 2017 Dishant Langayan
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dishant.demo.fxfeed;

import java.util.Map;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.dishant.demo.fxfeed.model.Quote;
import com.solacesystems.jcsmp.BytesMessage;
import com.solacesystems.jcsmp.JCSMPException;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.JCSMPSession;
import com.solacesystems.jcsmp.JCSMPStreamingPublishEventHandler;
import com.solacesystems.jcsmp.SessionEvent;
import com.solacesystems.jcsmp.SessionEventArgs;
import com.solacesystems.jcsmp.SessionEventHandler;
import com.solacesystems.jcsmp.SpringJCSMPFactory;
import com.solacesystems.jcsmp.Topic;
import com.solacesystems.jcsmp.XMLMessageProducer;

/**
 * The Raptor Feed Publisher. Publishes market data generated by the
 * {@link FeedGenerator} to a Solace Message Router.
 * 
 * @author Dishant Langayan
 */
@Component
public class FeedPublisher implements SessionEventHandler, JCSMPStreamingPublishEventHandler {
    private static final Logger logger = LoggerFactory.getLogger(FeedPublisher.class);

    private static final String NO_DATA_MSG_BODY = "{\"errorMsg\": \"NO_DATA_AVAILABLE\"}";

    private FxFeedConfigProperties config;

    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;
    private ScheduledFuture<?> handle;

    @Autowired
    private SpringJCSMPFactory solaceFactory;
    private JCSMPSession session;
    private XMLMessageProducer producer;
    private BytesMessage message;
    private volatile boolean isSessionConnected = false;

    @Autowired
    private FeedCache feedCache;

    public FeedPublisher(FxFeedConfigProperties config) {
        this.config = config;
    }

    @PostConstruct
    public void activate() throws Exception {
        logger.info("Starting feed publisher...");

        logger.info("Creating a Solace connection...");
        session = solaceFactory.createSession(null, this);
        producer = session.getMessageProducer(this);

        // Producer session is now hooked up and running!
        isSessionConnected = true;
        logger.info("Connected to Solace");

        // Pre-create the message we will use to publish
        // this message will be reused.
        message = JCSMPFactory.onlyInstance().createMessage(BytesMessage.class);

        // Topic prefix for all quotes published
        String topicPrefix = config.getTopicPrefix();

        // Start publishing at a scheduled interval
        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);
        handle = scheduledThreadPoolExecutor.scheduleWithFixedDelay(new Runnable() {
            public void run() {
                // TODO: record application Metrics

                // Ensure session is connected if not then reconnect
                if (!isSessionConnected) {
                    logger.info("Solace session is DOWN - feed publish will stop - "
                            + "consider configuring auto-reconnects");
                    handle.cancel(false);
                    return;
                }

                Map<String, Quote> cache = feedCache.getQuotes();
                if (cache == null || cache.isEmpty()) {
                    logger.info("No quotes to publish - internal cache is empty");
                    return;
                }

                try {
                    for (Map.Entry<String, Quote> entry : cache.entrySet()) {
                        // Create topic
                        Topic topic = JCSMPFactory.onlyInstance().createTopic(topicPrefix + entry.getKey());

                        // Reset the message first
                        message.reset();

                        // Message body
                        if (entry.getValue() != null) {
                            message.writeAttachment(entry.getValue().toJsonString().getBytes());
                        } else {
                            message.writeAttachment(NO_DATA_MSG_BODY.getBytes());
                        }

                        // Publish the message
                        producer.send(message, topic);
                    }
                } catch (JCSMPException e) {
                    logger.error("Exception while publishing message to Solace", e);
                }
            }
        }, 0, config.getPublishInterval(), TimeUnit.SECONDS);

        logger.info("Feed publisher has started");
    }

    @PreDestroy
    public void deactivate() throws Exception {
        logger.info("Feed publisher is stopping and disconnecting from Solace...");

        // Stop publishing thread
        if (handle != null) {
            handle.cancel(true);
        }

        // Close session
        if (session != null) {
            session.closeSession();
        }

        logger.info("Feed publisher has stopped gracefully");
    }

    @Override
    public void handleError(String messageID, JCSMPException cause, long timestamp) {
        logger.error("Received an error for published message [messageId: {} timestamp: {}]", messageID, timestamp,
                cause);
    }

    @Override
    public void responseReceived(String messageID) {
        logger.info("Received an unexpected response for published message with ID: {}", messageID);
    }

    @Override
    public void handleEvent(SessionEventArgs event) {
        SessionEvent sessionEvent = event.getEvent();
        switch (sessionEvent) {
        case DOWN_ERROR:
            isSessionConnected = false;
            logger.warn("Solace session was disconnected [Event: {}, ResponseCode: {}, Info: {}]",
                    sessionEvent.toString(), event.getResponseCode(), event.getInfo());
            break;
        case RECONNECTED:
            isSessionConnected = true;
            logger.info("Solace session has been reconnected successfully [Event: {}, ResponseCode: {}, Info: {}]",
                    sessionEvent.toString(), event.getResponseCode(), event.getInfo());
            break;
        case RECONNECTING:
            isSessionConnected = false;
            logger.info("Solace session is reconnecting [Event: {}, ResponseCode: {}, Info: {}]",
                    sessionEvent.toString(), event.getResponseCode(), event.getInfo());
            break;
        default:
            logger.debug("Solace SessionEvent [Event: {}, ResponseCode: {}, Info: {}]", sessionEvent.toString(),
                    event.getResponseCode(), event.getInfo());
            break;
        }
    }

}
